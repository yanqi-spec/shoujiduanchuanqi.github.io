<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>勇者传说 - 点击攻击版</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(125deg, #0b0f19, #131c2b, #1a2a40);
      color: white;
      font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      padding: 10px;
      touch-action: none;
    }

    #gameContainer {
      position: relative;
      width: min(95vw, 640px);
      height: min(95vw * 0.75, 480px);
      max-width: 640px;
      max-height: 480px;
      border-radius: 16px;
      overflow: hidden;
      box-shadow:
        0 12px 30px rgba(0, 0, 0, 0.6),
        inset 0 0 0 1px rgba(100, 150, 255, 0.15);
      backdrop-filter: blur(2px);
      cursor: pointer;
    }

    #gameCanvas {
      background: #0d1b2a;
      image-rendering: pixelated;
      display: block;
      width: 100%;
      height: 100%;
    }

    #titleBar {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 12px 0;
      text-align: center;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(6px);
      font-size: 20px;
      font-weight: bold;
      letter-spacing: 2px;
      color: #64b5f6;
      z-index: 11;
      border-bottom: 1px solid rgba(100, 181, 246, 0.2);
    }

    #uiPanel {
      position: absolute;
      top: 42px;
      left: 12px;
      background: rgba(15, 23, 42, 0.75);
      padding: 10px 12px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(100, 150, 255, 0.25);
      font-size: 14px;
      z-index: 10;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    #uiPanel span {
      font-weight: bold;
      color: #4fc3f7;
    }

    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      font-size: 24px;
      font-weight: 800;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      z-index: 20;
      text-shadow:
        0 0 8px rgba(255, 255, 255, 0.9),
        0 0 20px gold;
      color: white;
      transition: 
        opacity 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
        transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .show {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
    }

    .damage-text {
      position: absolute;
      font-size: 16px;
      font-weight: bold;
      color: #ff5252;
      text-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
      pointer-events: none;
      z-index: 15;
      animation: floatUp 1s forwards;
    }

    @keyframes floatUp {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-40px); opacity: 0; }
    }

    #pauseButton {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background-color: rgba(50, 70, 90, 0.8);
      color: white;
      border: none;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      border-radius: 8px;
      z-index: 12;
    }

    /* 虚拟摇杆 */
    #joystickContainer {
      position: absolute;
      bottom: 12px;
      left: 12px;
      width: 100px;
      height: 100px;
      z-index: 12;
      pointer-events: none;
    }

    #joystickBase {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(50, 80, 130, 0.3);
      border-radius: 50%;
      border: 2px solid rgba(100, 180, 255, 0.4);
      pointer-events: auto;
    }

    #joystickThumb {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 40px;
      height: 40px;
      background: rgba(100, 180, 255, 0.8);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: auto;
    }

    @media (min-width: 769px) {
      #joystickContainer {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="titleBar">⚔️ 勇者传说 - 点击攻击</div>
    <canvas id="gameCanvas" width="640" height="480"></canvas>
    <div id="uiPanel">
      ❤️ <span id="hp">100</span>/<span id="maxHp">100</span> |
      ⚔️<span id="atk">5</span> |
      Lv.<span id="level">1</span> |
      关卡:<span id="stage" onclick="toggleGodMode()">1</span>
    </div>

    <button id="pauseButton" onclick="togglePause()">|| 暂停</button>

    <!-- 移动端摇杆 -->
    <div id="joystickContainer">
      <div id="joystickBase"></div>
      <div id="joystickThumb"></div>
    </div>

    <div id="message">勇者传说</div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('gameContainer');

    // 全局状态
    let keys = {};
    let enemies = [];
    let damageTexts = [];
    let player = {
      x: 320,
      y: 240,
      size: 20,
      speed: 3,
      hp: 100,
      maxHp: 100,
      atk: 5,
      level: 1,
      exp: 0,
      expNeeded: 3,
      attackCooldown: 0,
      flash: 0,
      invincible: false
    };

    let currentStage = 1;
    let gameOver = false;
    let gameWon = false;
    let paused = false;
    let spawnIntervalId = null;

    // 无敌模式
    let godClickCount = 0;
    let godModeEnabled = false;

    // 虚拟摇杆
    let joystickActive = false;
    let joystickVector = { x: 0, y: 0 };
    let joystickBaseRect = null;

    // 初始化输入
    function setupInput() {
      window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.key === ' ') tryAttack();
      });
      window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
      });

      // 👉 点击/触摸整个游戏区域触发攻击
      gameContainer.addEventListener('click', tryAttack);
      gameContainer.addEventListener('touchstart', (e) => {
        // 防止与摇杆冲突：如果点在摇杆区域，不触发攻击
        const thumb = document.getElementById('joystickThumb');
        const thumbRect = thumb.getBoundingClientRect();
        const touch = e.touches[0] || e.changedTouches[0];
        const inThumb = (
          touch.clientX >= thumbRect.left &&
          touch.clientX <= thumbRect.right &&
          touch.clientY >= thumbRect.top &&
          touch.clientY <= thumbRect.bottom
        );
        if (!inThumb) {
          e.preventDefault(); // 阻止默认行为（如滚动）
          tryAttack();
        }
      }, { passive: false });
    }

    function tryAttack() {
      if (player.attackCooldown <= 0 && !gameOver && !gameWon && !paused) {
        player.attackCooldown = 10; // 10帧 ≈ 0.17秒（60fps）
        player.flash = 5;
        attack();
      }
    }

    function attack() {
      for (let enemy of enemies) {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 60) {
          enemy.hp -= player.atk;
          createDamageText(enemy.x, enemy.y, player.atk);
          if (enemy.hp <= 0) {
            killEnemy(enemy);
          }
        }
      }
    }

    function createDamageText(x, y, amount) {
      damageTexts.push({
        x: x,
        y: y,
        text: amount.toString(),
        life: 60
      });
    }

    function killEnemy(enemy) {
      const index = enemies.indexOf(enemy);
      if (index !== -1) enemies.splice(index, 1);
      player.exp += 1;
      checkLevelUp();
      checkStageClear();
    }

    function checkLevelUp() {
      if (player.exp >= player.expNeeded) {
        player.level++;
        player.exp -= player.expNeeded;
        player.expNeeded = Math.floor(player.expNeeded * 1.5);
        player.maxHp += 10;
        player.hp = player.maxHp;
        player.atk += 2;
        updateUI();
        showMessage(`升级！Lv.${player.level}`, true);
      }
    }

    function checkStageClear() {
      if (enemies.length === 0 && !gameWon) {
        if (currentStage >= 100) {
          gameWon = true;
          showMessage("🎉 通关成功！你完成了100关！", true);
          clearInterval(spawnIntervalId);
          return;
        }
        currentStage++;
        startStage(currentStage);
        showMessage(`第 ${currentStage} 关`, true);
      }
    }

    function startStage(stage) {
      enemies = [];
      const count = Math.min(5 + Math.floor(stage / 5), 20);
      for (let i = 0; i < count; i++) {
        let x, y;
        do {
          x = Math.random() * (canvas.width - 40) + 20;
          y = Math.random() * (canvas.height - 40) + 20;
        } while (Math.hypot(x - player.x, y - player.y) < 100);
        enemies.push({
          x: x,
          y: y,
          size: 15 + Math.random() * 10,
          hp: 10 + Math.floor(stage / 3),
          maxHp: 10 + Math.floor(stage / 3),
          speed: 0.5 + Math.random() * 0.5,
          color: `hsl(${200 + stage * 2 % 360}, 70%, 60%)`
        });
      }
      updateUI();
    }

    function spawnRandomMinions() {
      if (enemies.length < 30 && !gameOver && !gameWon && !paused) {
        let x = Math.random() < 0.5 ? -20 : canvas.width + 20;
        let y = Math.random() * canvas.height;
        enemies.push({
          x: x,
          y: y,
          size: 15,
          hp: 10,
          maxHp: 10,
          speed: 1,
          color: '#f44336'
        });
      }
    }

    function updateUI() {
      document.getElementById('hp').textContent = player.hp;
      document.getElementById('maxHp').textContent = player.maxHp;
      document.getElementById('atk').textContent = player.atk;
      document.getElementById('level').textContent = player.level;
      document.getElementById('stage').textContent = currentStage;
    }

    function showMessage(text, permanent = false) {
      const msg = document.getElementById('message');
      msg.textContent = text;
      msg.classList.add('show');
      if (!permanent) {
        setTimeout(() => hideMessage(), 2000);
      }
    }

    function hideMessage() {
      document.getElementById('message').classList.remove('show');
    }

    function togglePause() {
      paused = !paused;
      document.getElementById('pauseButton').textContent = paused ? '▶ 继续' : '|| 暂停';
      if (!paused) gameLoop();
    }

    // 👑 点击关卡6次开启/关闭无敌
    function toggleGodMode() {
      godClickCount++;
      if (godClickCount >= 6) {
        godModeEnabled = !godModeEnabled;
        player.invincible = godModeEnabled;
        showMessage(godModeEnabled ? "👑 无敌已开启！" : "🛡️ 无敌已关闭", true);
        setTimeout(() => hideMessage(), 1500);
        godClickCount = 0;
      } else {
        showMessage(`${godClickCount}/6`, false);
      }
    }

    function movePlayer() {
      let dx = 0, dy = 0;

      // 键盘（PC）
      if (keys['w'] || keys['arrowup']) dy -= player.speed;
      if (keys['s'] || keys['arrowdown']) dy += player.speed;
      if (keys['a'] || keys['arrowleft']) dx -= player.speed;
      if (keys['d'] || keys['arrowright']) dx += player.speed;

      // 摇杆（移动端）
      if (joystickActive) {
        dx = joystickVector.x * player.speed * 2;
        dy = joystickVector.y * player.speed * 2;
      }

      if (dx !== 0 && dy !== 0) {
        const factor = 0.7071;
        dx *= factor;
        dy *= factor;
      }

      player.x += dx;
      player.y += dy;

      player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
    }

    function updateEnemies() {
      for (let enemy of enemies) {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0) {
          enemy.x += (dx / dist) * enemy.speed;
          enemy.y += (dy / dist) * enemy.speed;
        }

        if (dist < player.size + enemy.size && !player.invincible) {
          player.hp -= 0.5;
          if (player.hp <= 0) {
            player.hp = 0;
            gameOver = true;
            showMessage("💀 游戏结束", true);
            clearInterval(spawnIntervalId);
          }
        }
      }
    }

    function updateDamageTexts() {
      for (let i = damageTexts.length - 1; i >= 0; i--) {
        damageTexts[i].life--;
        damageTexts[i].y -= 1;
        if (damageTexts[i].life <= 0) {
          damageTexts.splice(i, 1);
        }
      }
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 玩家
      if (player.flash > 0) {
        ctx.fillStyle = '#ffffff';
        player.flash--;
      } else {
        ctx.fillStyle = player.invincible ? '#ffeb3b' : '#4caf50';
      }
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
      ctx.fill();

      // 敌人
      for (let enemy of enemies) {
        ctx.fillStyle = enemy.color;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
        ctx.fill();

        const barWidth = enemy.size * 2;
        const ratio = enemy.hp / enemy.maxHp;
        ctx.fillStyle = '#333';
        ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.size - 10, barWidth, 4);
        ctx.fillStyle = ratio > 0.5 ? '#4caf50' : ratio > 0.25 ? '#ff9800' : '#f44336';
        ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.size - 10, barWidth * ratio, 4);
      }

      // 伤害数字
      ctx.fillStyle = '#ff5252';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      for (let dt of damageTexts) {
        ctx.fillText(dt.text, dt.x, dt.y);
      }
    }

    function gameLoop() {
      if (paused || gameOver || gameWon) return;

      movePlayer();
      if (player.attackCooldown > 0) player.attackCooldown--;
      updateEnemies();
      updateDamageTexts();
      render();

      requestAnimationFrame(gameLoop);
    }

    function initJoystick() {
      if (window.innerWidth > 768) return;

      const base = document.getElementById('joystickBase');
      const thumb = document.getElementById('joystickThumb');

      let isDragging = false;

      function getTouchPos(e) {
        const rect = base.getBoundingClientRect();
        joystickBaseRect = rect;
        const touch = e.touches[0] || e.changedTouches[0] || e;
        return {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };
      }

      function updateJoystick(e) {
        if (!isDragging) return;
        const pos = getTouchPos(e);
        const centerX = joystickBaseRect.width / 2;
        const centerY = joystickBaseRect.height / 2;
        let dx = pos.x - centerX;
        let dy = pos.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const maxDistance = centerX * 0.8;

        if (distance > maxDistance) {
          dx = (dx / distance) * maxDistance;
          dy = (dy / distance) * maxDistance;
        }

        thumb.style.transform = `translate(${dx}px, ${dy}px)`;
        joystickVector.x = dx / maxDistance;
        joystickVector.y = dy / maxDistance;
      }

      function startDrag(e) {
        e.preventDefault();
        isDragging = true;
        joystickActive = true;
        updateJoystick(e);
      }

      function endDrag() {
        isDragging = false;
        joystickActive = false;
        joystickVector = { x: 0, y: 0 };
        thumb.style.transform = 'translate(0, 0)';
      }

      base.addEventListener('mousedown', startDrag);
      base.addEventListener('touchstart', startDrag, { passive: false });
      window.addEventListener('mousemove', updateJoystick);
      window.addEventListener('touchmove', updateJoystick, { passive: false });
      window.addEventListener('mouseup', endDrag);
      window.addEventListener('touchend', endDrag);
    }

    function init() {
      startStage(1);
      setupInput();
      initJoystick();
      gameLoop();
      showMessage("点击任意处攻击 · 摇杆移动", true);
      setTimeout(() => hideMessage(), 2500);
      spawnIntervalId = setInterval(spawnRandomMinions, 2000);
    }

    window.onload = init;
  </script>
</body>
</html>