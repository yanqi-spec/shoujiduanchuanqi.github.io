<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>勇者传说 - 100关挑战</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(125deg, #0b0f19, #131c2b, #1a2a40);
      color: white;
      font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      padding: 10px;
      touch-action: none;
    }

    #gameContainer {
      position: relative;
      width: min(95vw, 640px);
      height: min(95vw * 0.75, 480px);
      max-width: 640px;
      max-height: 480px;
      border-radius: 16px;
      overflow: hidden;
      box-shadow:
        0 12px 30px rgba(0, 0, 0, 0.6),
        inset 0 0 0 1px rgba(100, 150, 255, 0.15);
      backdrop-filter: blur(2px);
    }

    #gameCanvas {
      background: #0d1b2a;
      image-rendering: pixelated;
      display: block;
      width: 100%;
      height: 100%;
    }

    #titleBar {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 12px 0;
      text-align: center;
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(6px);
      font-size: 20px;
      font-weight: bold;
      letter-spacing: 2px;
      color: #64b5f6;
      z-index: 11;
      border-bottom: 1px solid rgba(100, 181, 246, 0.2);
    }

    #uiPanel {
      position: absolute;
      top: 42px;
      left: 12px;
      background: rgba(15, 23, 42, 0.75);
      padding: 10px 12px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(100, 150, 255, 0.25);
      font-size: 14px;
      z-index: 10;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    #uiPanel span {
      font-weight: bold;
      color: #4fc3f7;
    }

    #skillPanel {
      position: absolute;
      bottom: 12px;
      right: 12px;
      display: flex;
      gap: 6px;
      z-index: 10;
    }

    .skill {
      width: 44px;
      height: 44px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(20, 30, 50, 0.8);
      border: 2px solid #4fc3f7;
      color: white;
      font-size: 11px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s;
    }

    .skill:hover {
      transform: scale(1.05);
      border-color: #81d4fa;
    }

    .skill.cooldown {
      opacity: 0.5;
      border-color: #555;
      background: rgba(30, 40, 60, 0.8);
    }

    .skill-key {
      font-size: 16px;
      margin-bottom: 1px;
    }

    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      font-size: 24px;
      font-weight: 800;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      z-index: 20;
      text-shadow:
        0 0 8px rgba(255, 255, 255, 0.9),
        0 0 20px gold;
      color: white;
      transition: 
        opacity 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275),
        transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .show {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
    }

    .damage-text {
      position: absolute;
      font-size: 16px;
      font-weight: bold;
      color: #ff5252;
      text-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
      pointer-events: none;
      z-index: 15;
      animation: floatUp 1s forwards;
    }

    @keyframes floatUp {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-40px); opacity: 0; }
    }

    #pauseButton {
      position: absolute;
      bottom: 12px;
      left: 12px;
      background-color: rgba(50, 70, 90, 0.8);
      color: white;
      border: none;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      border-radius: 8px;
      z-index: 12;
    }

    #gameInstructions {
      position: absolute;
      top: 42px;
      right: 12px;
      background-color: rgba(50, 70, 90, 0.8);
      color: white;
      padding: 10px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      z-index: 10;
      font-size: 12px;
      line-height: 1.3;
      max-width: 180px;
    }

    #instructionsHeader {
      cursor: pointer;
      font-weight: bold;
      color: #64b5f6;
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #instructionsContent {
      transition: opacity 0.3s, max-height 0.3s ease-out;
      overflow: hidden;
    }

    #instructionsContent.collapsed {
      opacity: 0;
      max-height: 0 !important;
      padding: 0 !important;
    }

    /* 虚拟摇杆 */
    #joystickContainer {
      position: absolute;
      bottom: 12px;
      left: 12px;
      width: 100px;
      height: 100px;
      z-index: 12;
      pointer-events: none;
    }

    #joystickBase {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(50, 80, 130, 0.3);
      border-radius: 50%;
      border: 2px solid rgba(100, 180, 255, 0.4);
      pointer-events: auto;
    }

    #joystickThumb {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 40px;
      height: 40px;
      background: rgba(100, 180, 255, 0.8);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: auto;
    }

    @media (min-width: 769px) {
      #joystickContainer,
      #skillPanel.mobile-only {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div id="titleBar">⚔️ 勇者传说 - 100关挑战</div>
    <canvas id="gameCanvas" width="640" height="480"></canvas>
    <div id="uiPanel">
      ❤️ <span id="hp">100</span>/<span id="maxHp">100</span> |
      ⚔️<span id="atk">5</span> |
      Lv.<span id="level">1</span> |
      关卡:<span id="stage">1</span>
    </div>

    <div id="gameInstructions">
      <div id="instructionsHeader" onclick="toggleInstructions()">
        说明
        <span id="toggleIcon">▼</span>
      </div>
      <div id="instructionsContent">
        移动：左摇杆<br>
        攻击：右下角⚔️<br>
        Q/E/R：技能<br>
        击败所有敌人过关！
      </div>
    </div>

    <button id="pauseButton" onclick="togglePause()">|| 暂停</button>

    <!-- 移动端摇杆 -->
    <div id="joystickContainer">
      <div id="joystickBase"></div>
      <div id="joystickThumb"></div>
    </div>

    <!-- 移动端技能按钮 -->
    <div id="skillPanel" class="mobile-only">
      <div class="skill" id="btnAttackMobile">
        <div class="skill-key">⚔️</div>
        <div></div>
      </div>
      <div class="skill" id="btnQMobile">
        <div class="skill-key">Q</div>
        <div></div>
      </div>
      <div class="skill" id="btnEMobile">
        <div class="skill-key">E</div>
        <div></div>
      </div>
      <div class="skill" id="btnRMobile">
        <div class="skill-key">R</div>
        <div></div>
      </div>
    </div>

    <div id="message">勇者传说</div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // 全局状态
    let keys = {};
    let enemies = [];
    let damageTexts = [];
    let player = {
      x: 320,
      y: 240,
      size: 20,
      speed: 3,
      hp: 100,
      maxHp: 100,
      atk: 5,
      level: 1,
      exp: 0,
      expNeeded: 3,
      attackCooldown: 0,
      flash: 0,
      shield: 0,
      invincible: false
    };

    let currentStage = 1;
    let gameOver = false;
    let gameWon = false;
    let paused = false;
    let spawnIntervalId = null;

    // 虚拟摇杆状态
    let joystickActive = false;
    let joystickVector = { x: 0, y: 0 };
    let joystickBaseRect = null;

    // 初始化输入监听
    function setupInput() {
      window.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.key === ' ') {
          e.preventDefault();
          tryAttack();
        }
        if (e.key.toLowerCase() === 'q') useSkill('q');
        if (e.key.toLowerCase() === 'e') useSkill('e');
        if (e.key.toLowerCase() === 'r') useSkill('r');
      });

      window.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
      });
    }

    function tryAttack() {
      if (player.attackCooldown <= 0 && !gameOver && !gameWon && !paused) {
        player.attackCooldown = 20;
        player.flash = 5;
        attack();
      }
    }

    // 技能按钮绑定（PC）
    function setupSkillButtons() {
      document.getElementById('btnAttackMobile').addEventListener('click', tryAttack);
      document.getElementById('btnQMobile').addEventListener('click', () => useSkill('q'));
      document.getElementById('btnEMobile').addEventListener('click', () => useSkill('e'));
      document.getElementById('btnRMobile').addEventListener('click', () => useSkill('r'));
    }

    // 虚拟摇杆初始化
    function initJoystick() {
      const base = document.getElementById('joystickBase');
      const thumb = document.getElementById('joystickThumb');
      const container = document.getElementById('joystickContainer');

      if (window.innerWidth > 768) {
        container.style.display = 'none';
        return;
      }

      let isDragging = false;

      function getTouchPos(e) {
        const rect = base.getBoundingClientRect();
        joystickBaseRect = rect;
        const touch = e.touches[0] || e.changedTouches[0] || e;
        return {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };
      }

      function updateJoystick(e) {
        if (!isDragging) return;
        const pos = getTouchPos(e);
        const centerX = joystickBaseRect.width / 2;
        const centerY = joystickBaseRect.height / 2;
        let dx = pos.x - centerX;
        let dy = pos.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const maxDistance = centerX * 0.8;

        if (distance > maxDistance) {
          dx = (dx / distance) * maxDistance;
          dy = (dy / distance) * maxDistance;
        }

        thumb.style.transform = `translate(${dx}px, ${dy}px)`;
        joystickVector.x = dx / maxDistance;
        joystickVector.y = dy / maxDistance;
      }

      function startDrag(e) {
        e.preventDefault();
        isDragging = true;
        joystickActive = true;
        updateJoystick(e);
      }

      function endDrag() {
        isDragging = false;
        joystickActive = false;
        joystickVector = { x: 0, y: 0 };
        thumb.style.transform = 'translate(0, 0)';
      }

      base.addEventListener('mousedown', startDrag);
      base.addEventListener('touchstart', startDrag, { passive: false });

      window.addEventListener('mousemove', updateJoystick);
      window.addEventListener('touchmove', updateJoystick, { passive: false });

      window.addEventListener('mouseup', endDrag);
      window.addEventListener('touchend', endDrag);
    }

    // 普通攻击
    function attack() {
      for (let enemy of enemies) {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 60) {
          enemy.hp -= player.atk;
          createDamageText(enemy.x, enemy.y, player.atk);
          if (enemy.hp <= 0) {
            killEnemy(enemy);
          }
        }
      }
    }

    // 使用技能
    function useSkill(skill) {
      if (paused || gameOver || gameWon) return;

      const now = Date.now();
      if (skill === 'q' && (player.lastQ === undefined || now - player.lastQ > 5000)) {
        player.lastQ = now;
        document.getElementById('btnQMobile').classList.add('cooldown');
        setTimeout(() => document.getElementById('btnQMobile').classList.remove('cooldown'), 5000);

        for (let enemy of enemies) {
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 100) {
            enemy.hp -= 20;
            createDamageText(enemy.x, enemy.y, 20);
            if (enemy.hp <= 0) {
              killEnemy(enemy);
            }
          }
        }
      }

      if (skill === 'e' && (player.lastE === undefined || now - player.lastE > 8000)) {
        player.lastE = now;
        document.getElementById('btnEMobile').classList.add('cooldown');
        setTimeout(() => document.getElementById('btnEMobile').classList.remove('cooldown'), 8000);

        player.shield = 120;
        player.invincible = true;
        setTimeout(() => {
          player.invincible = false;
        }, 2000);
      }

      if (skill === 'r' && (player.lastR === undefined || now - player.lastR > 10000)) {
        player.lastR = now;
        document.getElementById('btnRMobile').classList.add('cooldown');
        setTimeout(() => document.getElementById('btnRMobile').classList.remove('cooldown'), 10000);

        let targets = [...enemies].sort((a, b) => {
          const da = (a.x - player.x) ** 2 + (a.y - player.y) ** 2;
          const db = (b.x - player.x) ** 2 + (b.y - player.y) ** 2;
          return da - db;
        }).slice(0, 5);

        for (let enemy of targets) {
          enemy.hp -= 15;
          createDamageText(enemy.x, enemy.y, 15);
          if (enemy.hp <= 0) {
            killEnemy(enemy);
          }
        }
      }
    }

    function createDamageText(x, y, amount) {
      damageTexts.push({
        x: x,
        y: y,
        text: amount.toString(),
        life: 60
      });
    }

    function killEnemy(enemy) {
      const index = enemies.indexOf(enemy);
      if (index !== -1) enemies.splice(index, 1);
      player.exp += 1;
      checkLevelUp();
      checkStageClear();
    }

    function checkLevelUp() {
      if (player.exp >= player.expNeeded) {
        player.level++;
        player.exp -= player.expNeeded;
        player.expNeeded = Math.floor(player.expNeeded * 1.5);
        player.maxHp += 10;
        player.hp = player.maxHp;
        player.atk += 2;
        updateUI();
        showMessage(`升级！Lv.${player.level}`, true);
      }
    }

    function checkStageClear() {
      if (enemies.length === 0 && !gameWon) {
        if (currentStage >= 100) {
          gameWon = true;
          showMessage("🎉 通关成功！你完成了100关！", true);
          clearInterval(spawnIntervalId);
          return;
        }
        currentStage++;
        startStage(currentStage);
        showMessage(`第 ${currentStage} 关`, true);
      }
    }

    function startStage(stage) {
      enemies = [];
      const count = Math.min(5 + Math.floor(stage / 5), 20);
      for (let i = 0; i < count; i++) {
        let x, y;
        do {
          x = Math.random() * (canvas.width - 40) + 20;
          y = Math.random() * (canvas.height - 40) + 20;
        } while (Math.hypot(x - player.x, y - player.y) < 100);
        enemies.push({
          x: x,
          y: y,
          size: 15 + Math.random() * 10,
          hp: 10 + Math.floor(stage / 3),
          maxHp: 10 + Math.floor(stage / 3),
          speed: 0.5 + Math.random() * 0.5,
          color: `hsl(${200 + stage * 2 % 360}, 70%, 60%)`
        });
      }
      updateUI();
    }

    function spawnRandomMinions() {
      if (enemies.length < 30 && !gameOver && !gameWon && !paused) {
        let x = Math.random() < 0.5 ? -20 : canvas.width + 20;
        let y = Math.random() * canvas.height;
        enemies.push({
          x: x,
          y: y,
          size: 15,
          hp: 10,
          maxHp: 10,
          speed: 1,
          color: '#f44336'
        });
      }
    }

    function updateUI() {
      document.getElementById('hp').textContent = player.hp;
      document.getElementById('maxHp').textContent = player.maxHp;
      document.getElementById('atk').textContent = player.atk;
      document.getElementById('level').textContent = player.level;
      document.getElementById('stage').textContent = currentStage;
    }

    function showMessage(text, permanent = false) {
      const msg = document.getElementById('message');
      msg.textContent = text;
      msg.classList.add('show');
      if (!permanent) {
        setTimeout(() => hideMessage(), 2000);
      }
    }

    function hideMessage() {
      document.getElementById('message').classList.remove('show');
    }

    function togglePause() {
      paused = !paused;
      document.getElementById('pauseButton').textContent = paused ? '▶ 继续' : '|| 暂停';
      if (!paused) {
        gameLoop();
      }
    }

    function toggleInstructions() {
      const content = document.getElementById('instructionsContent');
      const icon = document.getElementById('toggleIcon');
      if (content.classList.contains('collapsed')) {
        content.classList.remove('collapsed');
        icon.textContent = '▲';
      } else {
        content.classList.add('collapsed');
        icon.textContent = '▼';
      }
    }

    function movePlayer() {
      let dx = 0, dy = 0;

      // 键盘输入
      if (keys['w'] || keys['arrowup']) dy -= player.speed;
      if (keys['s'] || keys['arrowdown']) dy += player.speed;
      if (keys['a'] || keys['arrowleft']) dx -= player.speed;
      if (keys['d'] || keys['arrowright']) dx += player.speed;

      // 虚拟摇杆输入（优先级更高）
      if (joystickActive) {
        dx = joystickVector.x * player.speed * 2;
        dy = joystickVector.y * player.speed * 2;
      }

      if (dx !== 0 && dy !== 0) {
        const factor = 0.7071;
        dx *= factor;
        dy *= factor;
      }

      player.x += dx;
      player.y += dy;

      player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
      player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
    }

    function updateEnemies() {
      for (let enemy of enemies) {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0) {
          enemy.x += (dx / dist) * enemy.speed;
          enemy.y += (dy / dist) * enemy.speed;
        }

        if (dist < player.size + enemy.size && !player.invincible) {
          player.hp -= 0.5;
          if (player.hp <= 0) {
            player.hp = 0;
            gameOver = true;
            showMessage("💀 游戏结束", true);
            clearInterval(spawnIntervalId);
          }
        }
      }
    }

    function updateDamageTexts() {
      for (let i = damageTexts.length - 1; i >= 0; i--) {
        damageTexts[i].life--;
        damageTexts[i].y -= 1;
        if (damageTexts[i].life <= 0) {
          damageTexts.splice(i, 1);
        }
      }
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 玩家
      if (player.flash > 0) {
        ctx.fillStyle = '#ffffff';
        player.flash--;
      } else {
        ctx.fillStyle = player.shield > 0 ? '#4fc3f7' : '#4caf50';
      }
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
      ctx.fill();

      if (player.shield > 0) {
        ctx.strokeStyle = '#81d4fa';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size + 8, 0, Math.PI * 2);
        ctx.stroke();
        player.shield--;
      }

      // 敌人
      for (let enemy of enemies) {
        ctx.fillStyle = enemy.color;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
        ctx.fill();

        const barWidth = enemy.size * 2;
        const ratio = enemy.hp / enemy.maxHp;
        ctx.fillStyle = '#333';
        ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.size - 10, barWidth, 4);
        ctx.fillStyle = ratio > 0.5 ? '#4caf50' : ratio > 0.25 ? '#ff9800' : '#f44336';
        ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.size - 10, barWidth * ratio, 4);
      }

      // 伤害数字
      ctx.fillStyle = '#ff5252';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      for (let dt of damageTexts) {
        ctx.fillText(dt.text, dt.x, dt.y);
      }
    }

    function gameLoop() {
      if (paused || gameOver || gameWon) return;

      movePlayer();
      if (player.attackCooldown > 0) player.attackCooldown--;
      updateEnemies();
      updateDamageTexts();
      render();

      requestAnimationFrame(gameLoop);
    }

    function init() {
      startStage(1);
      setupInput();
      setupSkillButtons();
      initJoystick();
      gameLoop();
      showMessage("勇者传说 - 100关挑战", true);
      setTimeout(() => hideMessage(), 2500);

      spawnIntervalId = setInterval(spawnRandomMinions, 2000);
    }

    window.onload = init;
  </script>
</body>
</html>